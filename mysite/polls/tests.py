import datetime

from django.test import TestCase
from django.utils import timezone
from django.urls import reverse

from .models import Question


def create_question(question_text, days):
    """
    Function for creating question cases with publish date offset
    :param question_text: text
    :param days: offset from now()
    :return: Question object
    """
    time = timezone.now() + datetime.timedelta(days=days)
    return Question.objects.create(question_text=question_text, pub_date = time)


# Create your tests here.
class QuestionModelTests(TestCase):
    def test_was_published_recently_future_date(self):
        """
        was_published_recently() returns False if question.pub_date is in the future
        :return: True if future date is not recent, else False
        """
        time = timezone.now() + datetime.timedelta(days=30)
        future_question = Question(pub_date=time)

        self.assertIs(future_question.was_published_recently(), False, msg="Future date test failed")

    def test_was_published_recently_recent_question(self):
        """
        was_published_recently() returns True if question.pub_date is within the last day
        :return: True if question within day past is recent, else False
        """
        time = timezone.now() - datetime.timedelta(hours=23, minutes=59, seconds=59)
        recent_question = Question(pub_date=time)

        self.assertIs(recent_question.was_published_recently(), True)


class QuestionIndexViewTests(TestCase):
    def test_no_question(self):
        """
        :return: True if no questions msg is displayed, else False
        """
        response = self.client.get(reverse("polls:index"))
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, "No polls are available")
        self.assertQuerySetEqual(response.context["latest_questions"], [])

    def test_past_questions(self):
        """
        :return: True if past published questions are displayed, else False
        """

        question = create_question("test", days=-30)
        response = self.client.get(reverse("polls:index"))
        self.assertQuerySetEqual(response.context["latest_questions"], [question])

    def test_future_questions(self):
        """
        :return: True if future published questions are not displayed, else False
        """
        create_question("test", days=30)
        response = self.client.get(reverse("polls:index"))
        self.assertQuerySetEqual(response.context["latest_questions"], [])
        self.assertContains(response, "No polls are available")

    def test_future_and_past_questions(self):
        """
        :return: True if both future published questions are not displayed and past ones are , else False
        """
        question = create_question("test1", days=-30)
        create_question("test2", days=30)
        response = self.client.get(reverse("polls:index"))
        self.assertQuerySetEqual(response.context["latest_questions"], [question])

    def test_multiple_past_questions(self):
        """
        :return: True if multiple questions are displayed from most recent ones, else False
        """
        question1 = create_question("test1", -30)
        question2 = create_question("test2", -10)
        response = self.client.get(reverse("polls:index"))

        self.assertQuerySetEqual(response.context["latest_questions"], [question2, question1])


# Generated by CodiumAI

class TestQuestion(TestCase):

    #  Creating a new question with valid question_text and pub_date should successfully create a Question object
    def test_create_question_successfully(self):
        question_text = "What is your favorite color?"
        pub_date = timezone.now()
        question = Question(question_text=question_text, pub_date=pub_date)
        self.assertIsInstance(question, Question)

    #  The __str__ method should return the question_text attribute of the Question object
    def test_str_method_returns_question_text(self):
        question_text = "What is your favorite color?"
        pub_date = timezone.now()
        question = Question(question_text=question_text, pub_date=pub_date)
        self.assertEqual(str(question), question_text)

    #  The was_published_recently method should return True if the pub_date attribute is within the
    #  last day, and False otherwise
    def test_was_published_recently_within_last_day(self):
        pub_date = timezone.now() - datetime.timedelta(hours=23, minutes=59, seconds=59)
        question = Question(pub_date=pub_date)
        self.assertTrue(question.was_published_recently())

    #  Creating a new question with an empty question_text attribute should raise a ValueError
    def test_create_question_with_empty_question_text_raises_value_error(self):
        with self.assertRaises(ValueError):
            pub_date = timezone.now()
            question = Question(question_text="", pub_date=pub_date)

    #  Creating a new question with a pub_date in the future should still create a Question object
    def test_create_question_with_future_pub_date(self):
        question_text = "What is your favorite color?"
        pub_date = timezone.now() + datetime.timedelta(days=1)
        question = Question(question_text=question_text, pub_date=pub_date)
        self.assertIsInstance(question, Question)

    #  The was_published_recently method should return False if the pub_date attribute
    #  is more than one day in the past
    def test_was_published_recently_more_than_one_day_in_past(self):
        pub_date = timezone.now() - datetime.timedelta(days=2)
        question = Question(pub_date=pub_date)
        self.assertFalse(question.was_published_recently())
